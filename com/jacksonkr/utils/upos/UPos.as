package com.jacksonkr.utils.upos{	import flash.display.DisplayObjectContainer;	import flash.display.Stage;	import flash.events.Event;	import flash.utils.setTimeout;	import flash.external.ExternalInterface;		/**	 * EXAMPLE: keeps "this" at a constant 31 pixels above the bottom (aka stageheight);	 * UPos.glue(this, UPos.ANCHOR, UPos.NONE, UPos.BOTTOM, {x:0, y:-31});	 *	 */		// controls Unique Stage Positioning. 	public class UPos {		public static const ANCHOR:String = "anchor";		public static const RELATIVE:String = "relative";		public static const NONE:String = "none";		public static const LEFT:String = "left";		public static const CENTER:String = "center";		public static const RIGHT:String = "right";		public static const TOP:String = "top";		public static const MIDDLE:String = "middle";		public static const BOTTOM:String = "bottom";				private static var _items:Object = new Array();				private static function parentPropsOf(obj:UPosObject):Object {			if(!obj) throw new ArgumentError("an Object is required.");						var p:* = obj.itemContainer;						if(!p) throw new Error("The object must have a parent, stage or specified container.");						var o:Object = {};			if(p.stage) {				o.w = p.stage.stageWidth;				o.h = p.stage.stageHeight;			} else {				o.w = p.width;				o.h = p.height;			}						if((o.w === undefined) || (o.h === undefined)) throw new Error("weren't able to determine width/height");						return o;		}				public static function createAnchorOffset(obj:UPosObject):Object {			var wh:Object = parentPropsOf(obj);							if(!wh) throw new Error("UPos->createOffset; width / height processing is required.");						switch(obj.anchorY) {				case NONE:				case TOP:					obj.offsetY = obj.item.y;				break;				case MIDDLE:					obj.offsetY = obj.item.y - wh.h / 2;				break;				case BOTTOM:					obj.offsetY = obj.item.y - wh.h;				break;			}			switch(obj.anchorX) {				case NONE:				case LEFT: 					obj.offsetX = obj.item.x;				break;				case CENTER:					obj.offsetX = obj.item.x - wh.w / 2;				break;				case RIGHT:					obj.offsetX = obj.item.x - wh.w;				break;			}						return obj;		}		/**		 * EXAMPLE: keeps "this" 31 pixels above the bottom of the stage		 * UPos.glue(this, stage, UPos.ANCHOR, UPos.BOTTOM, {x:0, y:-31});		 */		 // item:Object, type:String="anchor", anchor_x:String="left", anchor_y:String="top", offset:Object=null		public static function glue(obj:UPosObject):void {			switch(obj.type) {				case UPos.RELATIVE:					_items.push(obj);				break;				case UPos.ANCHOR:					if(!obj.anchorX && !obj.anchorY) throw new Error("You must specify at least one anchor.");										if(obj.anchorX && isNaN(obj.offsetX)) throw new Error("Because you specified a x-axis anchor, you must specify a x-axis offset.");					if(obj.anchorY && isNaN(obj.offsetY)) throw new Error("Because you specified an y-axis anchor, you must specify an y-axis offset.");										_items.push(obj);				break;				default:					throw new Error(obj.type, "is not a valid position type.");				break;			}						var func:Function = function(event:Event):void {				UPos.update(obj);			}						// attach a listener to the item's stage			obj.item.stage.addEventListener(Event.RESIZE, func);						// make sure the item is aligned based on glue			obj.item.stage.dispatchEvent(new Event(Event.RESIZE));		}		public static function update(obj:UPosObject):void {			var to_x:Number;			var to_y:Number;						var wh:Object = parentPropsOf(obj);						switch(obj.type) {				case UPos.RELATIVE:				break;				case UPos.ANCHOR:					switch(obj.anchorX) {						case LEFT:							to_x = 0;						break;						case CENTER:							to_x = wh.w / 2;						break;						case RIGHT:							to_x = wh.w;						break;						case NONE:						default:						break;					}					switch(obj.anchorY) {						case TOP:							to_y = 0;						break;						case MIDDLE:							to_y = wh.h / 2;						break;						case BOTTOM:							to_y = wh.h;						break;						case NONE:						default:						break;					}				break;			}						if(obj.offsetX) to_x += obj.offsetX;			if(obj.offsetY) to_y += obj.offsetY;						if(!isNaN(to_x)) obj.item.x = to_x;			if(!isNaN(to_y)) obj.item.y = to_y;		}	}}